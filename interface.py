from getpass import getpass

class Interface:
    
    def __init__(self):
        # Initialise the interface object when main.py is run.
        self.uid = None
        self.urole = None
        self.first_name = None
        
        self.motd() # call motd to display
    
    
    def motd(self):
        '''
        Display the motd including privacy and data policies. Prompts user to accept the ToS.
        If user agrees, display login prompt. If user disagrees, terminate CLI.
        '''
        pass
    
    
    def login(self):
        '''
        Asks user to enter username and password. If combination is found, logs user in and saves the user id, role and first name.
        If combination is incorrect after third try, that specific user will be locked from logging in again.
        '''  
        inpt_username = self.username_input()
        inpt_password = getpass(prompt="Please enter you Password: ")
        # auth_user = authentication.existing_user(inpt_username,inpt_password) -> tuple(uid, urole, firstname, status, last_login)
        # check if locked account
        # check if first time login
        # set uid, urole and firstname
        # print(f"Access Granted! Welcome back, {self.firstname}.")
        self.handle_main()
    
    
    def handle_main(self):
        '''
        Handler to display main menu options based on user's role.
        1 = Administrator
        2 = Specialist
        3 = Third-Party Authority
        '''
        if self.urole == 1:
            self.admin_menu()
        elif self.urole == 2:
            self.specialist_menu()
        elif self.urole == 3:
            self.authority_menu()
        else:
            print(f"Error: User Role not set correctly. Current value set to: {self.urole}")
    
    
    def admin_menu(self):
        '''
        Displays main menu options for the administrator role. Depending on choice, will trigger the operation from the admin_operations module.
        Choices include:
        Creating a new user, modifying an existing user, deactivating (soft deleting) an existing user, unlocking a user, logout.
        '''
        print('''
            \nPlease select what you want to do:\n 
            \n 1. Create New User
            \n 2. Modify Existing User
            \n 3. Deactivate User
            \n 4. Unlock User 
            \n 5. Logout
            ''')
        choice = self.choice_input(5)
        if choice == 1:
            self.create_user()
        elif choice == 2:
            self.modify_user()
        elif choice == 3:
            self.deactivate_user()
        elif choice == 4:
            self.unlock_user()
        else:
            self.logout()
        
    
    def specialist_menu(self):
        '''
        Displays main menu options for the specialist (employee) role. Depending on choice, will trigger the operation from the operations module.
        Choices include: Search existing sources, create a new source, logout.
        '''
        print('''
            \nPlease select what you want to do:\n 
            \n 1. Search Source
            \n 2. Create New Source Entry
            \n 3. Logout
            ''')
        choice = self.choice_input(3)
        if choice == 1:
            self.search_sources()
        elif choice == 2:
            self.create_source()
        else
            self.logout()
            
    
    def authority_menu(self):
        '''
        Displays main menu options for the authority (third-party) role. Depending on choice, will trigger the operation from the operations module.
        Choices include: Search existing sources, logout.
        '''
        print('''
            \nPlease select what you want to do:\n 
            \n 1. Search Source
            \n 2. Logout
            ''')
        choice = self.choice_input(2)
        if choice == 1:
            self.search_sources()
        else
            self.logout()
    
    
    def create_user(self):
        '''
        Prompts information and inputs for new user creation. If entered details pass validation, calls admin_operations module to execute the creation on
        the database level. Validation rules:
        
        First Name: >2 characters and may only contain letters, spaces and '-'
        Last Name: >2 characters and may only contain letters, spaces and '-'
        Date of Birth: Exactly 10 characters and may only contain numbers and '/'
        Email: Must contain exactly 1x '@' and atleast 1x '.' and end with a letter. May contain alphanum and '-', '.', '_', '+'
        
        If user is registered successfully, the user password will be autogenerated and sent to the user's email address.
        '''
        print('''
            \nCreating a New User
            \n---------------------------\n
            ''')
        inpt_first = self.name_input("First")
        inpt_last = self.name_input("Last")
        inpt_email = self.email_input()
        inpt_dob = self.dob_input()
        
        print('''
            \nPlease select the user role:\n
            \n 1. Administrator
            \n 2. Specialist
            \n 3. External Authority
            ''')
        inpt_role = self.choice_input(3)
        # admin_operations.register(inputs)
        print("\nUser has successfully been created!")
        
        choice = self.y_n_input("Do you want to create another user? y/n")
        if choice == 'y':
            self.create_user()
        else:
            self.admin_menu()
        

    def modify_user(self):
        pass
    
    
    def deactivate_user(self):
        pass
    
    
    def unlock_user(self):
        '''
        Prompts dialogue for unlocking a locked-out user.
        If successful, the user in question will have his status changed back to 'active'
        '''
        print('''
            \nUnlock an Existing User
            \n---------------------------\n
            ''')
        unlock_email = self.email_input()
        
        # Query Information from admin_operations
        # Show error message if user not found ("Entered user email is invalid. Please check and try again.")
        # If user is locked, display information back (e.g. UID, first name, last name, role and email)
        choice = self.y_n_input("Are you sure you want to unlock this user? y/n")
        if choice == 'y':
            # change user status to 'Active'
            print("\nUser has successfully been unlocked! The User can now login again.")
        else:
            print("\nUser has not been unlocked.")
        self.admin_menu()

    
    
    def search_sources(self):
        pass
    
    
    def create_source(self):
        pass
    
    
    def logout(self):
        # Message to be displayed when logout is chosen.
        print(f"Thank you for using the NCSC Suspect Sources System. See you soon, {self.first_name}!")
        quit()
    
    
    def choice_input(self, num_choices:int) -> int:
        '''
        Wrapper to validate the user input for a menu selection. The amount of different options to choose from can be set
        with the argument "num_choices".
        
        Returns the chosen option as an Integer.
        '''
        user_input = input("\nSelect option: ")
        try:
            int_input = int(user_input)
        except:
            print("Invalid selection. Please check your input and try again.")
            return self.choice_input(num_choices)
        if int_input > 0 and int_input <= num_choices:
            return int_input
        else:
            print("Invalid selection. Please check your input and try again.")
            return self.choice_input(num_choices)    
    
    
    def username_input(self) -> str:
        '''
        Wrapper to validate and sanitise the user input for username.
        Ensures that entered string is following the validation rules and, if so, returns the entered string.
        '''
        VALID_CHAR = ('.','_','-')
        MIN_LEN = 5
        
        input_user = input("\nPlease enter your Username: ")
        
        if len(input_user) < MIN_LEN: # checks the length of the entered username
            print("Entered username is invalid. Please check and try again.")
            return self.username_input()
        
        for char in input_user: # checks each character of user input 
            if char.isalnum(): 
                continue # continue if current char is either alpha or numerical
            elif char in VALID_CHAR:
                continue # continue if current char is part of the valid characters tuple
            else:
                print("Entered username is invalid. Please check and try again.")
                return self.username_input()
            
        return input_user # returns entered string if all validation rules are met
    
    
    def name_input(self, name_type:str) -> str:
        '''
        Wrapper to validate and sanitise the user input for first and lastname.
        Ensures that entered string is following the validation rules and, if so, returns the entered string.
        
        >2 characters and may only contain letters, spaces and '-'
        
        The argument "name_type" defines whether the entered name is a first or last name.
        "first" = first name
        "last" = last name
        '''
        VALID_CHAR = (' ','-')
        MIN_LEN = 3
        
        input_name = input(f"\nPlease enter the User's {name_type} Name: ")
    
        if len(input_name) < MIN_LEN: # checks the length of the entered name
            print("Entered Name is invalid. Please check and try again.")
            return self.name_input(name_type)
        
        for char in input_name: # checks each character of name input 
            if char.isalpha(): 
                continue # continue if current char is a letter
            elif char in VALID_CHAR:
                continue # continue if current char is part of the valid characters tuple
            else:
                print("Entered Name is invalid. Please check and try again.")
                return self.name_input(name_type)
            
        return input_name # returns entered string if all validation rules are met
    
        
    def email_input(self) -> str:
        '''
        Wrapper to validate and sanitise the user input for email.
        Ensures that entered string is following the validation rules and, if so, returns the entered string.
        
        Must contain exactly 1x '@' and atleast 1x '.' and end with a letter. May contain alphanum and '-', '.', '_', '+'
        '''
        VALID_CHAR = ('-', '.', '_', '+')
        
        num_at_sign = 0
        contains_dot = False
        ends_with_letter = False
    
        input_email = input(f"\nPlease enter the User's Email Address: ")
        
        if input_email[-1].isalpha(): # checks if email ends with a letter
            ends_with_letter = True
            
        if '.' in input_email: # checks if email contains atleast one '.'
            contains_dot = True
            
        for char in input_email: # checks each character of name input
            if char.isalnum():
                continue # continue if character is a letter or number
            elif char in VALID_CHAR:
                continue # continue if character is part of the valid_char tuple
            elif char == '@':
                num_at_sign += 1 # counts the number of times the '@' sign appears
            else:
                print("Entered Email Address is invalid. Please check and try again.")
                return self.email_input()
        
        if num_at_sign == 1 and contains_dot and ends_with_letter:
            return input_email # if all validations are met, the input string is returned
        else:
            print("Entered Email Address is invalid. Please check and try again.")
            return self.email_input()
            
            
    def dob_input(self) -> str:
        '''
        Wrapper to validate and sanitise the user input date of birth.
        Ensures that entered string is following the validation rules and, if so, returns the entered string.
        
        Exactly 10 characters and may only contain numbers and '/'
        '''       
        VALID_CHAR = ('/')
        EXACT_LEN = 10
        
        input_dob = input(f"\nPlease enter the User's Date of Birth (Format DD/MM/YYYY): ")
        
        if input_dob != EXACT_LEN:
            print("Entered Date of Birth is invalid. Please check and try again.")
            return self.dob_input()
        
        for char in input_dob:
            if char.isnum():
                continue
            elif char in VALID_CHAR:
                continue
            else:
                print("Entered Date of Birth is invalid. Please check and try again.")
                return self.dob_input()
        
        return input_dob
           
        
    def y_n_input(self, question:str) -> str:
        '''
        Validates a yes/no question and returns the str if answer is either 'y' or 'n'.
        '''
        input_choice = input(question)
        
        if input_choice == 'y' or input_choice == 'n':
            return input_choice    
        else: 
            print("Please answer either 'y' for 'yes' or 'n' for 'no'.")
            return self.y_n_input(question)